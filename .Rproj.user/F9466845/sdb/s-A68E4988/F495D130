{
    "collab_server" : "",
    "contents" : "```{r include=FALSE, cache=FALSE}\nset.seed(1014)\noptions(digits = 3)\n\nknitr::opts_chunk$set(\n  message = FALSE,\n  warning = FALSE,\n  comment = \"#>\",\n  collapse = TRUE,\n  cache = TRUE,\n  out.width = \"70%\",\n  fig.align = 'center',\n  fig.width = 6,\n  fig.asp = 0.618,  # 1 / phi\n  fig.show = \"hold\"\n)\n\n```\n\n\n# Daten visualisieren\n\n\n```{r echo = FALSE, out.width = \"30%\", fig.align = \"center\"}\nknitr::include_graphics(\"images/FOM.jpg\")\n```\n\n```{r echo = FALSE, out.width = \"10%\", fig.align = \"center\"}\nknitr::include_graphics(\"images/licence.png\")\n```\n\n\n\n```{block2, ziele-vis, type='rmdcaution', echo = TRUE} \nLernziele:\n\n- An einem Beispiel erläutern können, warum/ wann ein Bild mehr sagt, als 1000 Worte.\n- Häufige Arten von Diagrammen erstellen können.\n- Diagramme bestimmten Zwecken zuordnen können.\n\n\n```\n\n\nIn diesem Kapitel werden folgende Pakete benötigt::\n```{r libs_visualisieren}\nlibrary(tidyverse)  # Zum Plotten\n# library(car)  # Umkodieren\n# library(knitr)  # HTML-Tabellen\n\n```\n\n\n```{r plot-vis, echo = FALSE}\nknitr::include_graphics(\"images/visualisieren/Visualisieren.pdf\")\n```\n\n\nDieses Kapitel erläutert das Daten visualisieren anhand des R-Pakets `ggplot2`.\n\n## Ein Bild sagt mehr als 1000 Worte\n\n\nEin Bild sagt bekanntlich mehr als 1000 Worte. Schauen wir uns zur Verdeutlichung das berühmte Beispiel von Anscombe^[https://de.wikipedia.org/wiki/Anscombe-Quartett] an. Es geht hier um vier Datensätze mit zwei Variablen (Spalten; X und Y). Offenbar sind die Datensätze praktisch identisch: Alle X haben den gleichen Mittelwert und die gleiche Varianz; dasselbe gilt für die Y. Die Korrelation zwischen X und Y ist in allen vier Datensätzen gleich. Allerdings erzählt eine Visualisierung der vier Datensätze eine ganz andere Geschichte.\n\n\n```{r fig-anscombe, echo = FALSE, fig.cap = \"Das Anscombe-Quartett\"}\nknitr::include_graphics(\"images/visualisieren/anscombe.pdf\")\n```\n\n\nOffenbar \"passieren\" in den vier Datensätzen gänzlich unterschiedliche Dinge. Dies haben die Statistiken nicht aufgedeckt; erst die Visualisierung erhellte uns... Kurz: Die Visualisierung ist ein unverzichtbares Werkzeug, um zu verstehen, was in einem Datensatz (und damit in der zugrunde liegenden \"Natur\") passiert. \n\n\nEs gibt viele Möglichkeiten, Daten zu visualisieren (in R). Wir werden uns hier auf einen Weg bzw. ein Paket konzentrieren, der komfortabel, aber mächtig ist und gut zum Prinzip des Durchpfeifens passt: `ggplot2`^[\"gg\" steht für \"grammer of graphics\" nach einem Buch von Wilkinson[-@wilkinson2006grammar]; \"plot\" steht für \"to plot\", also ein Diagramm erstellen (\"plotten\"); vgl. https://en.wikipedia.org/wiki/Ggplot2].\n\n\n## Die Anatomie eines Diagramms\n\n`ggplot2` unterscheidet folgende Bestandteile (\"Anatomie\") eines Diagramms (vgl. Abb. \\@ref(fig:fig-anatomie)):\n\n- Daten\n- Abbildende Aspekte (Achsen, Farben, ...)\n- Geome (statistische Bilder wie Punkte, Linien, Boxplots, ...)\n\n\n```{r fig-anatomie, echo = FALSE, fig.cap = \"Anatomie eines Diagramms\"}\nknitr::include_graphics(\"images/anatomie_diagramm_crop.pdf\")\n```\n\nBei *Daten* muss ein Dataframe angegeben werden. Zu den *abbildenden Aspekte* (in `ggplot2` als \"aesthetics\" bezeichnet) zählen vor allem die Achsen, aber auch Farben u.a. Was ist mit abbildend gemeint? Weist man einer Achse einen Variable zu, so wird jede Ausprägung der Variablen einer Ausprägung der Achse zugeordnet (welcher Wert genau entscheidet `ggplot2` für uns, wenn wir es nicht explizieren). Mit *Geom* ist das eigentlich Art von \"Bild\" gemeint, wie Punkt, Linie oder Boxplot (vgl. Abschnitt \\@ref(geome)).\n\n## Einstieg in `ggplot2` - `qplot`\n\nLos geht's! Laden wir zuerst den Datensatz `nycflights::flights`.\n\n```{r}\ndata(flights, package = \"nycflights13\")\n```\n\n```{r include = FALSE, eval = FALSE}\nsource(\"includes/Pakete.R\")\n```\n\n\n```{r fig-flights, message = FALSE, fig.cap = \"Mittlere Verspätung nach Flugggesellschaft\"}\nqplot(x = carrier, y = arr_delay, geom = \"boxplot\", data = flights)\n```\n\nSchauen wir uns den Befehl `qplot` etwas näher an. Wie ist er aufgebaut?\n\n\n```{block2, qplot-syntax, type='rmdpseudocode', echo = TRUE}\n`qplot`: Erstelle schnell (q wie quick in `qplot`) mal einen Plot (engl. \"plot\": Diagramm).    \n`x`: Der X-Achse soll die Variable \"carrier\" zugeordnet werden.    \n`y`: Der Y-Achse soll die Variable \"arr_dely\" zugeorndet werden.  \n`geom`: (\"geometriches Objekt\") Gemalt werden soll ein Boxplot, nicht etwa Punkte, Linien oder sonstiges.   \n`data`: Als Datensatz bitte `flights` verwenden.  \n\n```\n\n\n\nOffenbar gibt es viele Extremwerte, was die Verspätung betrifft. Das erscheint mir nicht unplausibel (Schneesturm im Winter, Flugzeug verschwunden...). Vor dem Hintergrund der Extremwerte erscheinen die mittleren Verspätungen (Mediane) in den Boxplots als ähnlich. Vielleicht ist der Unterschied zwischen den Monaten ausgeprägter?\n\n```{r}\nqplot(x = factor(month), y = arr_delay, geom = \"boxplot\", data = flights)\n```\n\nKaum ein Unterschied ersichtlich; das spricht gegen die Schneesturm-Idee als Grund für Verspätung. Aber schauen wir uns zuerst die Syntax von `qplot` näher an. \"q\" in `qplot` steht für \"quick\". Tatsächlich hat `qplot` einen großen Bruder, `ggplot`^[Achtung: Nicht `qqplot`, nicht `ggplot2`, nicht `gplot`...], der deutlich mehr Funktionen aufweist - und daher auch die umfangreichere (=komplexere) Syntax. Fangen wir mit `qplot` an.\n\n\nDiese Syntax des letzten Beispiels ist recht einfach, nämlich:\n\n```{r, eval = FALSE}\nqplot (x = X_Achse, y = Y_Achse, data = mein_dataframe, geom = \"ein_geom\")\n```\n\nWir definieren mit `x`, welche Variable der X-Achse des Diagramms zugewiesen werden soll, z.B. `month`; analog mit Y-Achse. Mit `data` sagen wir, in welchem Dataframe die Spalten \"wohnen\" und als \"geom\" ist die Art des statistischen \"*geom*etrischen Objects\" gemeint, also Punkte, Linien, Boxplots, Balken...\n\n## Häufige Arten von Diagrammen\nUnter den vielen Arten von Diagrammen und vielen Arten, diese zu klassifizieren greifen wir uns ein paar häufige Diagramme heraus und schauen uns diese der Reihe nach an.\n\n\n### Eine kontinuierliche Variable\n\nSchauen wir uns die Verteilung der Schuhgrößen von Studierenden an.\n\n```{r}\nwo_men <- read.csv(\"data/wo_men.csv\")\n\nqplot(x = shoe_size, data = wo_men)\n```\n\nWeisen wir nur der X-Achse (aber nicht der Y-Achse) eine kontinuierliche Variable zu, so wählt `ggplot2` automatisch als Geom automatisch ein Histogramm; wir müssen daher nicht explizieren, dass wir ein Histogramm als Geom wünschen (aber wir könnten es hinzufügen). Alternativ wäre ein Dichtediagramm hier von Interesse:\n\n```{r}\n# qplot(x = shoe_size, data = wo_men)  wie oben\n\nqplot(x = shoe_size, data = wo_men, geom = \"density\")\n\n```\n\nWas man sich merken muss, ist, dass hier nur das Geom mit Anführungsstrichen zu benennen ist, die übrigen Parameter *ohne*.\n\nVielleicht wäre es noch schön, beide Geome zu kombinieren in einem Diagramm. Das ist etwas komplizierter; wir müssen zum großen Bruder `ggplot` umsteigen, da `qplot` nicht diese Funktionen anbietet.\n\n```{r}\nggplot(data = wo_men) +\n  aes(x = shoe_size) +\n  geom_histogram(aes(y = ..density..), alpha = .7) +\n  geom_density(color = \"blue\")\n```\n\nZuerst haben wir mit dem Parameter `data` den Dataframe benannt. `aes` definiert, welche Variablen welchen Achsen (oder auch z.B. Füllfarben) zugewiesen werden. Hier sagen wir, dass die Schuhgröße auf X-Achse stehen soll. Das `+`-Zeichen trennt die einzelnen Bestandteile des `ggplot`-Aufrufs voneinander. Als nächstes sagen wir, dass wir gerne ein Histogram hätten: `geom_histogram`. Dabei soll aber nicht wie gewöhnlich auf der X-Achse die Häufigkeit stehen, sondern die Dichte. `ggplot` berechnet selbständig die Dichte und nennt diese Variable `..density..`; die vielen Punkte sollen wohl klar machen, dass es sich nicht um eine \"normale\" Variable aus dem eigenen Datenframe handelt, sondern um eine \"interne\" Variable von `ggplot` - die wir aber nichtsdestotrotz verwenden können. `alpha` bestimmt die \"Durchsichtigkeit\" eines Geoms; spielen Sie mal etwas damit herum. Schließlich malen wir noch ein blaues Dichtediagramm *über* das Histogramm.\n\nWünsche sind ein Fass ohne Boden... Wäre es nicht schön, ein Diagramm für Männer und eines für Frauen zu haben, um die Verteilungen vergleichen zu können?\n\n```{r}\nqplot(x = shoe_size, data = wo_men, geom = \"density\", color = sex)\nqplot(x = shoe_size, data = wo_men, geom = \"density\", fill = sex, alpha = I(.7))\n```\n\nHier sollten vielleicht noch die Extremwerte entfernt werden, um den Blick auf das Gros der Werte nicht zu verstellen:\n\n```{r}\n\nwo_men %>% \n  filter(shoe_size <= 47) -> wo_men2\n\nqplot(x = shoe_size, data = wo_men2, geom = \"density\", fill = sex, alpha = I(.7))\n\n```\n\nBesser. Man kann das Durchpfeifen auch bis zu `qplot` weiterführen:\n\n```{r}\nwo_men %>% \n  filter(shoe_size <= 47) %>% \n  qplot(x = shoe_size, data = ., geom = \"density\", fill = sex, alpha = I(.7))\n\n```\n\nDie Pfeife versucht im Standard, das Endprodukt des letzten Arbeitsschritts an den *ersten* Parameter des nächsten Befehls weiterzugeben. Ein kurzer Blick in die Hilfe von `qplot` zeigt, dass der erste Parameter nicht `data` ist, sondern `x`. Daher müssen wir explizit sagen, an welchen Parameter wir das Endprodukt des letzen Arbeitsschritts geben wollen. Netterweise müssen wir dafür nicht viel tippen: Mit einem schlichten Punkt `.` können wir sagen \"nimm den Dataframe, so wie er vom letzten Arbeitsschritt ausgegeben wurde\".\n\nMit `fill = sex` sagen wir `qplot`, dass er für Männer und Frauen jeweils ein Dichtediagramm erzeugen soll; jedem Dichtediagramm wird dabei eine Farbe zugewiesen (die uns `ggplot2` im Standard voraussucht). Mit anderen Worten: Die Werte von `sex` werden der Füllfarbe der Histogramme zugeordnet. Anstelle der Füllfarbe hätten wir auch die Linienfarbe verwenden können; die Syntax wäre dann: `color = sex`.\n\n### Zwei kontinuierliche Variablen\n\nEin Streudiagramm ist die klassische Art, zwei metrische Variablen darzustellen. Das ist mit `qplot` einfach:\n\n```{r}\nqplot(x = height, y = shoe_size, data = wo_men)\n```\n\nWir weisen wieder der X-Achse und der Y-Achse eine Variable zu; handelt es sich in beiden Fällen um Zahlen, so wählt `ggplot2` automatisch ein Streudiagramm - d.h. Punkte als Geom (`geom = \"point\"`). Wir sollten aber noch die Extremwerte herausnehmen:\n\n```{r}\nwo_men %>% \n  filter(height > 150, height < 210, shoe_size < 55) %>% \n  qplot(x = height, y = shoe_size, data = .)\n\n```\n\nDer Trend ist deutlich erkennbar: Je größer die Person, desto länger die Füß´. Zeichnen wir noch eine Trendgerade ein.\n\n\n```{r}\nwo_men %>% \n  filter(height > 150, height < 210, shoe_size < 55) %>% \n  qplot(x = height, y = shoe_size, data = .) +\n  geom_smooth(method = \"lm\")\n```\n\nSynonym könnten wir auch schreiben:\n\n```{r eval = FALSE}\nwo_men %>% \n  filter(height > 150, height < 210, shoe_size < 55) %>% \n  ggplot() +\n  aes(x = height, y = shoe_size) +\n  geom_point() +\n  geom_smooth(method = \"lm\")\n```\n\nDa `ggplot` als *ersten* Parameter die Daten erwartet, kann die Pfeife hier problemlos durchgereicht werden. *Innerhalb* eines `ggplot`-Aufrufs werden die einzelne Teile durch ein Pluszeichen `+` voneinander getrennt. Nachdem wir den Dataframe benannt haben, definieren wir die Zuweisung der Variablen zu den Achsen mit `aes` (\"aes\" wie \"aesthetics\", also das \"Sichtbare\" eines Diagramms, die Achsen etc., werden definiert). Ein \"Smooth-Geom\" ist eine Linie, die sich schön an die Punkte anschmiegt, in diesem Falls als Gerade (lineares Modell, `lm`).\n\nBei sehr großen Datensätze, sind Punkte unpraktisch, da sie sich überdecken (\"overplotting\"). Ein Abhilfe ist es, die Punkte nur \"schwach\" zu färben. Dazu stellt man die \"Füllstärke\" der Punkte über `alpha` ein: `geom_point(alpha = 1/100)`. Um einen passablen Alpha-Wert zu finden, bedarf es häufig etwas Probierens. Zu beachten ist, dass es mitunter recht lange dauert, wenn `ggplot` viele (>100.000) Punkte malen soll.\n\nBei noch größeren Datenmengen bietet sich an, den Scatterplot als \"Schachbrett\" aufzufassen, und das Raster einzufärben, je nach Anzahl der Punkte pro Schachfeld; zwei Geome dafür sind `geom_hex()` und `geom_bin2d()`.\n\n```{r flights_hexbin}\ndata(flights, package = \"nycflights13\")\nnrow(flights)  # groß!\n\nggplot(flights) +\n  aes(x = distance, y = air_time) +\n  geom_hex()\n```\n\n\nWenn man dies verdaut hat, wächst der Hunger nach einer Aufteilung in Gruppen.\n\n```{r fig-aes-color}\nwo_men %>% \n  dplyr::filter(height > 150, height < 210, shoe_size < 55) -> wo_men2\n\nwo_men2 %>% \n  qplot(x = height, y = shoe_size, color = sex, data = .)\n```\n\nMit `color = sex` sagen wir, dass die Linienfarbe (der Punkte) entsprechend der Stufen von `sex` eingefärbt werden sollen. Die genaue Farbwahl übernimmt `ggplot2` für uns.\n\n\nAlternativ kann man auch zwei \"Teil-Bildchen\" (\"facets\") erstellen, eines für Frauen und eines für Männer:\n\n```{r}\nwo_men %>% \n  dplyr::filter(height > 150, height < 210, shoe_size < 55) %>% \n  qplot(x = height, y = shoe_size, facets = \"~sex\", color = sex, data = .)\n```\n\nMan beachte die Tilde `~`, die vor die \"Gruppierungsvariable\" `sex` zu setzen ist.\n\n#### Vertiefung zu Facetten\n\nEin netter visueller Effekt wird erreicht, wenn in jeder Facette zwar alle Punkte gezeigt werden in einem leichten Grau. Aber farbig betont werden nur die Punkte, die zur jeweiligen Gruppe gehören. Der optische Eindruck erklärt es einfacher als Worte:\n\n```{r wo-men-facetten-bsp}\nwo_men %>% \n  dplyr::filter(height > 150, height < 210, shoe_size < 55) %>% \n  dplyr::select(-sex) -> wo_men4\n\nwo_men4 %>% \n  ggplot(ggplot2::aes(x = height, y = shoe_size)) +\n  geom_point(color = \"grey80\") +\n  # facet_wrap(~sex) +\n  geom_point(data = wo_men2, ggplot2::aes(color = sex))\n  \n```\n\n\nDer \"ggplot-Trick\" ist, zuerst die Punkte *ohne* Gruppierungsinformation (hier: `sex`) zu plotten. Danach plotten wir die nach Gruppenzugehörigkeit gefärbten Punkte.\n\n\n### Eine diskrete Variable\nBei diskreten Variablen, vor allem nominalen Variablen, geht es in der Regel darum, Häufigkeiten auszuzählen. Wie viele Männer und Frauen sind in dem Datensatz?\n\n```{r}\nqplot(x = sex, data = wo_men)\n```\n\nFalls nur die X-Achse definiert ist und dort eine Faktorvariable oder eine Text-Variable steht, dann nimmt `qplot` automatisch ein Balkendiagramm als Geom.\n\nEntfernen wir vorher noch die fehlenden Werte:\n\n```{r}\nwo_men %>% \n  na.omit() %>% \n  qplot(x = sex, data = .)\n```\n\nWir könnten uns jetzt die Frage stellen, wie viele kleine und viele große Menschen es bei Frauen und bei den Männern gibt. Dazu müssen wir zuerst eine Variable wie \"Größe gruppiert\" erstellen mit zwei Werten: \"klein\" und \"groß\". Nennen wir sie `groesse_gruppe`\n\n```{r}\nwo_men$groesse_gruppe <- car::recode(wo_men$height, \"lo:175 = 'klein'; else = 'gross'\")\n\nwo_men %>% \n  filter(height > 150, height < 210, shoe_size < 55) %>% \n  na.omit -> wo_men2\n  \nqplot(x = sex, fill = groesse_gruppe, data = wo_men2)\n\n```\n\nIn Worten sagt der `recode`-Befehl hier in etwa: \"Kodiere `wo_men$height` um, und zwar vom kleinsten (`lo`) Wert bis 170 soll den Wert `klein` bekommen, ansonsten bekommt eine Größe den Wert `gross`\".\n\nHier haben wir `qplot` gesagt, dass der die Balken entsprechend der Häufigkeit von `groesse_gruppe` füllen soll. Und bei den Frauen sind bei dieser Variablen die Werte `klein` häufig; bei den Männern hingegen die Werte `gross`.\n\nSchön wäre noch, wenn die Balken Prozentwerte angeben würden. Das geht mit `qplot` (so) nicht; wir schwenken auf `ggplot` um^[Cleveland fände diese Idee nicht so gut.].\n\n```{r}\nwo_men2 %>% \n  ggplot() +\n  aes(x = sex, fill = groesse_gruppe) +\n  geom_bar(position = \"fill\")\n```\n\nSchauen wir uns die Struktur des Befehls `ggplot` näher an.\n\n```{block2, ggplot-syntax, type='rmdpseudocode', echo = TRUE}\n\n`wo_men2`:  Hey R, nimm den Datensatz `wo_men2` UND DANN...  \n`ggpplot()` : Hey R, male ein Diagramm von Typ ggplot (mit dem Datensatz aus dem vorherigen Pfeifen-Schritt, d.h. aus der vorherigen Zeile, also `wo_men2`)!    \n`+`:  Das Pluszeichen grenzt die Teile eines ggplot-Befehls voneinander ab.  \n`aes`:  von \"aethetics\", also welche Variablen des Datensatzes den sichtbaren Aspekten (v.a. Achsen, Farben) zugeordnet werden.  \n`x`: Der X-Achse (Achtung, `x` wird klein geschrieben hier) wird die Variable `sex` zugeordnet.   \n`y`: gibt es nicht??? Wenn in einem ggplot-Diagramm *keine* Y-Achse definiert wird, wird ggplot automatisch ein Histogramm bzw. ein Balkendiagramm erstellen. Bei diesen Arten von Diagrammen steht auf der Y-Achse keine eigene Variable, sondern meist die Häufigkeit des entsprechenden X-Werts (oder eine Funktion der Häufigkeit, wie relative Häufigkeit).  \n`fill` Das Diagramm (die Balken) sollen so gefüllt werden, dass sich die Häufigkeit der Werte von `groesse_gruppe` darin widerspiegelt.  \n\n`geom_XYZ`: Als \"Geom\" soll ein Balken (\"bar\") gezeichnet werden.  Ein Geom ist in ggplot2 das zu zeichnende Objekt, also ein Boxplot, ein Balken, Punkte, Linien etc. Entsprechend wird gewünschte Geom mit `geom_bar`, `geom_boxplot`, geom_point` etc. gewählt.  \n\n`position = fill`: `position_fill` will sagen, dass die Balken alls eine Höhe von 100% (1) haben. Die Balken zeigen also nur die Anteile der Werte der `fill`-Variablen. \n\n```\n\n\n\nDie einzige Änderung in den Parametern ist `position = \"fill\"`. Dieser Parameter weist `ggplot` an, die Positionierung der Balken auf die Darstellung von Anteilen auszulegen. Damit haben alle Balken die gleiche Höhe, nämlich 100% (1). Aber die \"Füllung\" der Balken schwankt je nach der Häufigkeit der Werte von `groesse_gruppe` pro Balken (d.h. pro Wert von `sex`).\n\nWir sehen, dass die Anteile von großen bzw. kleinen Menschen bei den beiden Gruppen (Frauen vs. Männer) *unterschiedlich hoch* ist. Dies spricht für einen *Zusammenhang* der beiden Variablen; man sagt, die Variablen sind *abhängig* (im statistischen Sinne).\n\n>    Je unterschiedlicher die \"Füllhöhe\", desto stärker sind die Variablen (X-Achse vs. Füllfarbe) voneinander abhängig (bzw. desto stärker der Zusammenhang). \n\n\n\n### Zwei diskrete Variablen \nArbeitet man mit nominalen Variablen, so sind Kontingenztabellen Täglich Brot. Z.B.: Welche Produkte wurden wie häufig an welchem Standort verkauft? Wie ist die Verteilung von Alkoholkonsum und Körperform bei Menschen einer Single-Börse. Bleiben wir bei letztem Beispiel. \n\n\n```{r}\ndata(profiles, package = \"okcupiddata\")\n\nprofiles %>% \n  dplyr::count(drinks, body_type) %>% \n  ggplot +\n  aes(x = drinks, y = body_type, fill = n) +\n  geom_tile() +\n  theme(axis.text.x = element_text(angle = 90))\n\n```\n\nWas haben wir gemacht? Also:\n\n\n\n\n```{block2, fliesen-plot, type='rmdpseudocode', echo = TRUE}\nNehme den Datensatz \"profiles\" UND DANN  \nZähle die Kombinationen von \"drinks\" und \"body_type\" UND DANN  \nErstelle ein ggplot-Plot UND DANN  \nWeise der X-Achse \"drinks\" zu, der Y-Achse \"body_type\" und der Füllfarbe \"n\" UND DANN  \nMale Fliesen UND DANN  \nPasse das Thema so an, dass der Winkel für Text der X-Achse auf 90 Grad steht.  \n\n```\n\n\n     \nWas sofort ins Auge sticht, ist dass \"soziales Trinken\", nennen wir es mal so, am häufigsten ist, unabhängig von der Körperform. Ansonsten scheinen die Zusammenhäng nicht sehr stark zu sein.     \n\n### Zusammenfassungen zeigen\nManchmal möchten wir *nicht* die Rohwerte einer Variablen darstellen, sondern z.B. die Mittelwerte pro Gruppe. Mittelwerte sind eine bestimmte *Zusammenfassung* einer Spalte; also fassen wir zuerst die Körpergröße zum Mittelwert zusammen - gruppiert nach Geschlecht.\n\n```{r}\nwo_men2 %>% \n  group_by(sex) %>% \n  summarise(Groesse_MW = mean(height)) -> wo_men3\n\nwo_men3\n```\n\n\nDiese Tabelle schieben wir jetzt in `ggplot2`; natürlich hätten wir das gleich in einem Rutsch durchpfeifen können.\n\n```{r}\nwo_men3 %>% \n  qplot(x = sex, y = Groesse_MW, data = .)\n```\n\nDas Diagramm besticht nicht durch die Tiefe und Detaillierung. Wenn wir noch zusätzlich die Mittelwerte nach `Groesse_Gruppe` ausweisen, wird das noch überschaubar bleiben.\n\n```{r}\nwo_men2 %>% \n  group_by(sex, groesse_gruppe) %>% \n  summarise(Groesse_MW = mean(height)) %>% \n  qplot(x = sex, color = factor(groesse_gruppe), y = Groesse_MW, data = .)\n```\n\n## Die Gefühlswelt von `ggplot2`\n\n- Geben Sie eine *diskrete X-Achs*e an und *keine Y-AchseÜ, so greift qplot im Standard auf das Geom `bar` zurück (Balkendiagramm), falls Sie kein Geom angeben:\n\n```{r eval = FALSE}\nqplot(x = smoker, data = tips)  # identisch zu\nqplot(x = smoker, data = tips, geom = \"bar)\n\n```\n\n- Geben Sie eine *kontinuierliche X-Achse* an und *keine Y-Achse*, so greift qplot im Standard auf das Geom `histogram` zurück (Histogramm).\n\n```{r echo = FALSE}\ndata(tips, package = \"reshape\")\n```\n\n\n```{r eval = FALSE}\nqplot(x = smoker, data = tips)  # identisch zu\nqplot(x = smoker, data = tips, geom = \"histogram\")\n```\n\n- Geben Sie eine *kontinuierliche X-Achse* an und eine *kontinuierliche Y-Achse* an, so greift qplot im Standard auf das Geom `point` zurück (Streudiagramm).\n\n```{r eval = FALSE}\nqplot(x = total_bill, y = tip, data = tips)  # identisch zu\nqplot(x = total_bill, y=  tip, data = tips, geom = \"point\")\n```\n\n- Möchten Sie mehrere Geome für eine Variable darstellen, so muss die Variable diskret sein:\n\n```{r eval = FALSE}\n#oh no: \nqplot(x = rating, y = affairs, geom = \"boxplot\", data = Affairs)\n\n#oh yes: \nqplot(x = factor(rating), y = affairs, geom = \"boxplot\", data = Affairs)\n\n#oh yes: \nqplot(x = gender, y = affairs, geom = \"boxplot\", data = Affairs)\n```\n\n\n\n## Aufgaben\n\n1. Erzählen Sie einer vertrauenswürdigen Person jeweils eine \"Geschichte\", die das Zustandekommen der vier Plots von Anscombe (Abb. \\@ref(fig:fig-anscombe)) erklärt!\n\n1. Abb. \\@ref(fig:fig-flights) stellt die mittlere Verspätung verschiedener Fluggesellschaften dar; als \"Geom\" wird ein Boxplot verwendet. Andere Geome wären auch möglich - aber wie sinnvoll wären sie?\n\n1. Erstellen Sie ein Diagramm, welches Histogramme der Verspätung verwendet anstelle von Boxplots! Damit das Diagramm nicht so groß wird, nehmen Sie zur Gruppierung nicht `carrier` sondern `origin`.\n\n1. Ist das Histogramm genauso erfolgreich wie der Boxplot, wenn es darum geht, viele Verteilungen vergleichend zu präsentieren? Warum?\n\n1. Erstellen Sie ein sehr grobes und ein sehr feines Histogramm für die Schuhgröße!\n\n\n1. Vertiefung: Erstellen Sie ein Diagramm, das sowohl eine Zusammenfassung (Mittelwert) der Körpergrößen nach Geschlecht darstellt als auch die einzelnen Werte darstellt!\n\n\n\n\n## Lösungen\n\n1. :-)\n\n2. :\n\n```{r}\nqplot(x = arr_delay, geom = \"histogram\", data = flights, facets = \"~origin\")\n```\n\nDer Boxplot ist besser geeignet, um mehrere Verteilungen vergleichend zu präsentieren. Durch die gleiche Ausrichtung der Boxplots ist es dem Auge viel einfacher, Vergleiche anzustellen im Vergleich zu den Histogrammen. Einen optisch schönenen Effekt könnte man mit `geom_jitter` anstelle von `geom_point`erreichen. Auch die Reihenfolge der beiden Geome könnte man umdrehen. Natürlich ist auch an Form, Größe und Farbe der Geome noch zu feilen.\n\n\n3. :\n\n```{r}\nqplot(x = shoe_size, data = wo_men, bins = 10)\nqplot(x = shoe_size, data = wo_men, bins = 50)\n```\n\n4. :\n\n```{r}\nwo_men2 %>% \n  group_by(sex) %>% \n  summarise(height = mean(height)) -> wo_men3\n\n\nwo_men3 %>% \n  ggplot() +\n  aes(x = sex, y = height) +\n  geom_point(color = \"red\", size = 8) +\n  geom_point(data = wo_men2, color = \"grey80\")\n```\n\nDer \"Trick\" ist hier, erst die zusammengefassten Daten in ein Geom zu stecken (`wo_men3`). Dann werden die Rohdaten (`wo_men2`) ebenfalls in ein Geom gepackt. Allerdings muss die Achsen-Beschriftung bei beiden Geomen identisch sein, sonst gibt es eine Fehlermeldung.\n\n\n## Richtig oder Falsch^[R, R, F, F, R]\n\n```{block2, exercises-visualisieren, type='rmdexercises', echo = TRUE} \nRichtig oder Falsch!?\n\n1. Diese Geome gehören zum (Standard-) ggplot2: bar, histogram, point, density, jitter, boxplot.\n\n1. `qplot` ist eine Funktion im Paket `ggplot2`.\n\n1. Mi `aes` definiert man, wie \"ästethisch\" das Diagramm sein soll (z.B. grauer Hintergrund vs. weißer Hintergrund, Farbe der Achsen etc.).\n\n1. Diese Geome gehören zum (Standard-) ggplot2: smooth, line, boxwhisker, mosaicplot.\n\n1. Möchte man ein Diagramm erstellen, welches auf der X-Achse `total_bill`, auf der Y-Achse `tip` darstellt, als Geom Punkte verwendet und die Daten aus der Tabelle `tips` bezieht, so ist folgende Syntax korrekt: `qplot(x = total, bill, y = tip, geom = \"point\", data = tips)\n\n\n```\n\n\n## Befehlsübersicht\n\n\nPaket::Funktion        Beschreibung\n-----------------      -------------\nggplot2::qplot         Malt schnell mal einen Plot\nggplot2::ggplot        Malt einen Plot\nfactor                 Wandelt einen Vektor in den Typ `factor` um\n\n\n## Vertiefung: Geome bei ggplot2 {#geome}\n\nEinen guten Überblick über Geome bietet das Cheatsheet von ggplot2^[https://www.rstudio.com/wp-content/uploads/2015/03/ggplot2-cheatsheet.pdf].\n\nVerschiedenen Taxonomien von statistischen \"Bildchen\" sind denkbar; eine einfache ist die folgende; es wird nur ein Teil der verfügbaren Geome dargestellt.\n\n1. Eine kontinuerliche Variable\n\n```{r echo = FALSE}\np1 <- \n  ggplot(tips) +\n  aes(x = total_bill) +\n  geom_histogram() +\n  labs(title = \"geom_histogram\")\n\np2 <-\n  ggplot(tips) +\n  aes(x = total_bill) +\n  geom_density() +\n  labs(title = \"geom_density\")\n\nlibrary(gridExtra)\n\ngrid.arrange(p1, p2, ncol = 2)\n```\n\n\n2. Zwei kontinuierliche Variablen\n\n```{r echo = FALSE}\n\np1 <- \n  ggplot(tips) +\n  aes(x = total_bill, y = tip) +\n  geom_point() +\n  labs(title = \"geom_point\")\n\np2 <- \n  ggplot(tips) +\n  aes(x = total_bill, y = tip) +\n  geom_point() +\n  labs(title = \"geom_jitter -\\nverwackelt\")\n\np3 <- \n  ggplot(tips) +\n  aes(x = total_bill, y = tip) +\n  geom_smooth() +\n  labs(title = \"geom_smooth\")\n\ngrid.arrange(p1, p2, p3, ncol = 3)\n```\n\n3. Eine diskrete Variable (X-Achse)\n\n```{r}\n\nggplot(tips) +\n  aes(x = day) +\n  geom_bar()\n```\n\n\n4. Eine diskrete Variable auf der X-Achse und eine kontinuierliche Y-Achse\n\n```{r echo = FALSE}\np1 <- \nggplot(tips) +\n  aes(x = sex, y = tip) +\n  geom_boxplot() +\n  labs(title = \"geom_boxplot\")\n\np2 <- \nggplot(tips) +\n  aes(x = sex, y = tip) +\n  geom_violin() +\n  labs(title = \"geom_violin\")\n\ngrid.arrange(p1, p2, ncol = 2)\n\n```\n\n\n## Verweise\n\n- Einen Befehlsüberblick zu `ggplot2` findet sich hier: http://ggplot2.tidyverse.org/reference/.\n\n- Edward Tufte gilt als Grand Seigneur der Datenvisualisierung; er hat mehrere lesenswerte Bücher zu dem Thema geschrieben [@1930824130; @1930824165; @1930824149].\n\n- William Cleveland, ein amerikanischer Statistiker ist bekannt für seine grundlegenden, und weithin akzeptierten Ansätze für Diagramme, die die wesentliche Aussage schnörkellos transportieren [@Cleveland]. \n\n- Die (graphische) Auswertung von Umfragedaten basiert häufig auf Likert-Skalen. Ob diese metrisches Niveau aufweisen, darf bezweifelt werden. Hier findet sich einige vertiefenden Überlegungen dazu und zur Frage, wie Likert-Daten ausgewertet werden könnten: https://bookdown.org/Rmadillo/likert/. \n\n- Es finden sich viele Tutorials online zu `ggplot2`; ein deutschsprachiger Tutorial findet sich hier: http://md.psych.bio.uni-goettingen.de/mv/unit/ggplot2/ggplot2.html.\n\n\n\n\n\n\n",
    "created" : 1493219878322.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "4178985459",
    "id" : "F495D130",
    "lastKnownWriteTime" : 1493219992,
    "last_content_update" : 1493219992513,
    "path" : "~/Documents/Publikationen/In_Arbeit/Praxis_der_Datenanalyse/050_Daten_visualisieren.Rmd",
    "project_path" : "050_Daten_visualisieren.Rmd",
    "properties" : {
        "docOutlineVisible" : "1",
        "ignored_words" : "Durchpfeifens,gg,grammer,graphics,Wilkinson,Ggplot,q,etrischen,Objects,Geoms,Füß,aes,aesthetics,Smooth,overplotting,Füllstärke,Rmadillo,likert\n"
    },
    "relative_order" : 11,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_markdown"
}