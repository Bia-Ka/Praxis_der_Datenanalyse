{
    "collab_server" : "",
    "contents" : "#' @import stats utils\n\nbookdown_file = function(...) {\n  system.file(..., package = 'bookdown', mustWork = TRUE)\n}\n\n# find the y[j] closest to x[i] with y[j] > x[i]; x and y have been sorted\nnext_nearest = function(x, y, allow_eq = FALSE) {\n  n = length(x); z = integer(n)\n  for (i in seq_len(n)) z[i] = y[if (allow_eq) y >= x[i] else y > x[i]][1]\n  z\n}\n\n# change the filename extension\nwith_ext = function(x, ext) {\n  n1 = length(x); n2 = length(ext); r = '([.][[:alnum:]]+)?$'\n  if (n1 * n2 == 0) return(x)\n  i = !(grepl('^[.]', ext) | ext == '')\n  ext[i] = paste0('.', ext[i])\n\n  if (all(ext == '')) ext = ''\n  if (length(ext) == 1) return(sub(r, ext, x))\n\n  if (n1 > 1 && n1 != n2) stop(\"'ext' must be of the same length as 'x'\")\n  mapply(sub, r, ext, x, USE.NAMES = FALSE)\n}\n\n# counters for figures/tables\nnew_counters = function(type, rownames) {\n  base = matrix(\n    0L, nrow = length(rownames), ncol = length(type),\n    dimnames = list(rownames, type)\n  )\n  list(\n    inc = function(type, which) {\n      base[which, type] <<- base[which, type] + 1L\n    }\n  )\n}\n\n# set some internal knitr options\nset_opts_knit = function(config) {\n  # use labels of the form (\\#label) in knitr\n  config$knitr$opts_knit$bookdown.internal.label = TRUE\n  # when the output is LaTeX, force LaTeX tables instead of default Pandoc tables\n  # http://tex.stackexchange.com/q/276699/9128\n  config$knitr$opts_knit$kable.force.latex = TRUE\n  config\n}\n\nreadUTF8 = function(input) {\n  x = readLines(input, encoding = 'UTF-8', warn = FALSE)\n  i = invalidUTF8(x)\n  n = length(i)\n  if (n > 0) warning(\n    'The file ', input, ' is not encoded in UTF-8. These lines contain invalid ',\n    'UTF-8 characters: ', paste(c(head(i), if (n > 6) '...'), collapse = ', ')\n  )\n  x\n}\n\nwriteUTF8 = function(text, ...) {\n  writeLines(enc2utf8(text), ..., useBytes = TRUE)\n}\n\n# which lines are invalid UTF-8\ninvalidUTF8 = function(x) {\n  which(is.na(iconv(x, 'UTF-8', 'UTF-8')))\n}\n\nget_base_format = function(format) {\n  if (is.character(format)) {\n    format = eval(parse(text = format))\n  }\n  if (!is.function(format)) stop('The output format must be a function')\n  format\n}\n\nload_config = function() {\n  if (length(opts$get('config')) == 0 && file.exists('_bookdown.yml')) {\n    # store the book config\n    opts$set(config = yaml::yaml.load_file('_bookdown.yml'))\n  }\n  opts$get('config')\n}\n\nbook_filename = function(config = load_config(), fallback = TRUE) {\n  if (is.character(config[['book_filename']])) {\n    config[['book_filename']][1]\n  } else if (fallback) '_main'\n}\n\nsource_files = function(format = NULL, config = load_config(), all = FALSE) {\n  # a list of Rmd chapters\n  files = list.files(\n    '.', '[.]Rmd$', ignore.case = TRUE, recursive = isTRUE(config[['rmd_subdir']])\n  )\n  if (length(config[['rmd_files']]) > 0) {\n    files = config[['rmd_files']]\n    if (is.list(files)) {\n      files = if (all && is.null(format)) unlist(files) else files[[format]]\n    }\n  } else {\n    files = files[grep('^[^_]', basename(files))]  # exclude those start with _\n    index = match('index', with_ext(files, ''))\n    # if there is a index.Rmd, put it in the beginning\n    if (!is.na(index)) files = c(files[index], files[-index])\n  }\n  check_special_chars(files)\n}\n\noutput_dirname = function(dir, config = load_config(), create = TRUE) {\n  if (is.null(dir)) {\n    dir2 = config[['output_dir']]\n    if (!is.null(dir2)) dir = dir2\n  }\n  if (is.null(dir)) dir = '_book'\n  if (length(dir)) {\n    if (create) dir_create(dir)\n    # ignore dir that is just the current working directory\n    if (same_path(dir, getwd(), mustWork = FALSE)) dir = NULL\n  }\n  dir\n}\n\ndir_exists = function(x) utils::file_test('-d', x)\n\n# mark directories with trailing slashes\nmark_dirs = function(x) {\n  i = dir_exists(x)\n  x[i] = paste0(x[i], '/')\n  x\n}\n\nclean_empty_dir = function(dir) {\n  if (!dir_exists(dir)) return()\n  files = list.files(dir, all.files = TRUE, recursive = TRUE)\n  if (length(files) == 0) unlink(dir, recursive = TRUE)\n}\n\nmerge_chapters = function(files, to, before = NULL, after = NULL, orig = files) {\n  # in the preview mode, only use some placeholder text instead of the full Rmd\n  preview = opts$get('preview'); input = opts$get('input_rmd')\n  content = unlist(mapply(files, orig, SIMPLIFY = FALSE, FUN = function(f, o) {\n    x = readUTF8(f)\n    x = if (preview && !(o %in% input)) create_placeholder(x) else {\n      insert_code_chunk(x, before, after)\n    }\n    c(x, '', paste0('<!--chapter:end:', o, '-->'), '')\n  }))\n  if (preview && !(files[1] %in% input))\n    content = c(fetch_yaml(readUTF8(files[1])), content)\n  writeUTF8(content, to)\n}\n\nmatch_dashes = function(x) grep('^---\\\\s*$', x)\n\ncreate_placeholder = function(x) {\n  h = grep('^# ', x, value = TRUE)  # chapter title\n  h1 = grep(reg_part, h, value = TRUE)\n  h2 = setdiff(h, h1)\n  c('', if (length(h1)) h1[1], if (length(h2)) h2[1] else '# Placeholder')\n}\n\nfetch_yaml = function(x) {\n  i = match_dashes(x)\n  if (length(i) >= 2) x[(i[1]):(i[2])]\n}\n\ninsert_code_chunk = function(x, before, after) {\n  if (length(before) + length(after) == 0) return(x)\n  if (length(x) == 0 || length(match_dashes(x[1])) == 0) return(c(before, x, after))\n  i = match_dashes(x)\n  if (length(i) < 2) {\n    warning('There may be something wrong with your YAML frontmatter (no closing ---)')\n    return(c(before, x, after))\n  }\n  # insert `before` after the line i[2], i.e. the second ---\n  c(append(x, before, i[2]), after)\n}\n\ninsert_chapter_script = function(config, where = 'before') {\n  script = config[[sprintf('%s_chapter_script', where)]]\n  if (is.character(script)) {\n    c('```{r include=FALSE, cache=FALSE}', unlist(lapply(script, readUTF8)), '```')\n  }\n}\n\ncheck_special_chars = function(filename) {\n  reg = getFromNamespace('.shell_chars_regex', 'rmarkdown')\n  for (i in grep(reg, filename)) warning(\n    'The filename \"', filename[i], '\" contains special characters. ',\n    'You may rename it to, e.g., \"', gsub(reg, '-', filename[i]), '\".'\n  )\n  if (!is.null(i)) stop('Filenames must not contain special characters')\n  filename\n}\n\nRscript = function(args) {\n  system2(file.path(R.home('bin'), 'Rscript'), args)\n}\n\nRscript_render = function(file, ...) {\n  args = shQuote(c(bookdown_file('scripts', 'render_one.R'), file, ...))\n  if (Rscript(args) != 0) stop('Failed to compile ', file)\n}\n\nclean_meta = function(meta_file, files) {\n  meta = readRDS(meta_file)\n  for (i in setdiff(names(meta), files)) meta[[i]] = NULL\n  meta = setNames(meta[files], files)  # order by input filenames\n  for (i in files) if (is.null(meta[[i]])) meta[[i]] = basename(with_ext(i, '.md'))\n  saveRDS(meta, meta_file)\n  meta\n}\n\n# remove HTML tags and remove extra spaces\nstrip_html = function(x) {\n  x = gsub('<[^>]+>', '', x)\n  x = gsub('\\\\s{2,}', ' ', x)\n  x\n}\n\n# remove the <script><script> content and references\nstrip_search_text = function(x) {\n  x = gsub('<script[^>]*>(.*?)</script>', '', x)\n  x = gsub('<div id=\"refs\" class=\"references\">.*', '', x)\n  x = strip_html(x)\n  x\n}\n\n# quote a string and escape backslashes/double quotes\njson_string = function(x, toArray = FALSE) {\n  json_vector(x, toArray)\n}\n\njson_vector = function(x, toArray = FALSE, quote = TRUE) {\n  if (quote) {\n    x = gsub('([\"\\\\])', \"\\\\\\\\\\\\1\", x)\n    x = gsub('[[:space:]]', \" \", x)\n    if (length(x)) x = paste0('\"', x, '\"')\n  }\n  if (toArray) paste0('[', paste(x, collapse = ', '), ']') else x\n}\n\n# manipulate internal options\nopts = knitr:::new_defaults(list(config = list()))\n\ndir_create = function(path) {\n  dir_exists(path) || dir.create(path, recursive = TRUE)\n}\n\n# a wrapper of file.path to ignore `output_dir` if it is NULL\noutput_path = function(...) {\n  dir = opts$get('output_dir')\n  if (is.null(dir)) file.path(...) else file.path(dir, ...)\n}\n\nlocal_resources = function(x) {\n  grep('^(f|ht)tps?://.+', x, value = TRUE, invert = TRUE)\n}\n\n#' Create a book skeleton\n#'\n#' Write Rmd files (named in the form \\file{\\%02d-chapter-title.Rmd}) for\n#' chapters with the chapter titles specified, create the output format file\n#' \\file{_output.yml}, and generate the book configuration file\n#' \\file{_bookdown.yml}.\n#' @param name An ID for the book to be written to the \\code{book_filename}\n#'   field in \\code{_bookdown.yml} and used as the \\code{name} argument of\n#'   \\code{\\link{publish_book}()}. You can use the current directory name here.\n#' @param title,author The title and author of the book.\n#' @param chapters The chapter titles.\n#' @param documentclass The LaTeX document class.\n#' @param references The title of the references section.\n#' @noRd\nbook_skeleton = function(\n  name, title, author, chapters = c('Preface {-}', 'Introduction'),\n  documentclass = 'book', references = 'References'\n) {\n  rmd_files = gsub('[^-a-zA-Z0-9]', '', gsub('\\\\s+', '-', c(chapters, references)))\n  rmd_files = sprintf('%02d-%s.Rmd', seq_along(rmd_files) - 1, rmd_files)\n  rmd_files[1] = 'index.Rmd'\n  write_file = function(x, f) {\n    if (file.exists(f)) stop('The file ', f, ' exists.')\n    writeUTF8(x, f)\n  }\n  titles = c(chapters, sprintf(\"`r if (knitr:::is_html_output()) '# %s {-}'`\", references))\n  titles = paste('#', titles)\n  for (i in seq_along(rmd_files)) {\n    content = c(titles[i], '')\n    if (i == 1) {\n      content = c(\n        '---', sprintf('title: \"%s\"', title), sprintf('author: \"%s\"', author),\n        sprintf('documentclass: \"%s\"', documentclass),\n        'site: bookdown::bookdown_site', '---', '', content,\n        'Start writing your book here. If you are in RStudio,',\n        'Click the Build button to build the book.'\n      )\n    }\n    write_file(content, rmd_files[i])\n  }\n  write_file(\n    sprintf('bookdown::%s: default', c('gitbook', 'pdf_book', 'epub_book')), '_output.yml'\n  )\n  write_file(sprintf('book_filename: %s', name), '_bookdown.yml')\n}\n\n#' Continously preview the HTML output of a book using the \\pkg{servr} package\n#'\n#' When any files are modified or added to the book directory, the book will be\n#' automatically recompiled, and the current HTML page in the browser will be\n#' refreshed. This function is based on \\code{servr::\\link[servr]{httw}()} to\n#' continuously watch a directory.\n#'\n#' For \\code{in_session = TRUE}, you will have access to all objects created in\n#' the book in the current R session: if you use a daemonized server (via the\n#' argument \\code{daemon = TRUE}), you can check the objects at any time when\n#' the current R session is not busy; otherwise you will have to stop the server\n#' before you can check the objects. This can be useful when you need to\n#' interactively explore the R objects in the book. The downside of\n#' \\code{in_session = TRUE} is that the output may be different with the book\n#' compiled from a fresh R session, because the state of the current R session\n#' may not be clean.\n#'\n#' For \\code{in_sesion = FALSE}, you do not have access to objects in the book\n#' from the current R session, but the output is more likely to be reproducible\n#' since everything is created from new R sessions. Since this function is only\n#' for previewing purposes, the cleanness of the R session may not be a big\n#' concern. You may choose \\code{in_session = TRUE} or \\code{FALSE} depending on\n#' your specific applications. Eventually, you should run \\code{render_book()}\n#' from a fresh R session to generate a reliable copy of the book output.\n#' @param dir The root directory of the book (containing the Rmd source files).\n#' @param output_dir The directory for output files; see\n#'   \\code{\\link{render_book}()}.\n#' @param preview Whether to render the modified/added chapters only, or the\n#'   whole book; see \\code{\\link{render_book}()}.\n#' @param in_session Whether to compile the book using the current R session, or\n#'   always open a new R session to compile the book whenever changes occur in\n#'   the book directory.\n#' @param daemon,... Other arguments passed to \\code{servr::\\link[servr]{httw}()} (not\n#'   including the \\code{handler} argument, which has been set internally).\n#' @export\nserve_book = function(\n  dir = '.', output_dir = '_book', preview = TRUE, in_session = TRUE,\n  daemon = FALSE, ...\n) {\n  # when this function is called via the RStudio addin, use the dir of the\n  # current active document\n  if (missing(dir) && requireNamespace('rstudioapi', quietly = TRUE)) {\n    context_fun = tryCatch(\n      getFromNamespace('rstudioapi', 'getSourceEditorContext'),\n      error = function(e) rstudioapi::getActiveDocumentContext\n    )\n    path = context_fun()[['path']]\n    if (!(is.null(path) || path == '')) dir = dirname(path)\n  }\n  owd = setwd(dir); on.exit(setwd(owd), add = TRUE)\n  if (missing(output_dir) || is.null(output_dir)) {\n    on.exit(opts$restore(), add = TRUE)\n    output_dir = load_config()[['output_dir']]\n  }\n  if (is.null(output_dir)) output_dir = '_book'\n  if (missing(preview)) preview = getOption('bookdown.preview', TRUE)\n  if (missing(daemon)) daemon = getOption('bookdown.serve.daemon', FALSE)\n  output_format = first_html_format()\n  rebuild = function(..., preview_ = preview) {\n    files = grep('[.]R?md$', c(...), value = TRUE, ignore.case = TRUE)\n    i = match(sans_ext(book_filename()), sans_ext(basename(files)))\n    if (!is.na(i)) files = files[-i]\n    i = grep('[.](knit|utf8)[.]md$', files)\n    if (length(i)) files = files[-i]\n    if (length(files) == 0) return()\n    # if the output dir has been deleted, rebuild the whole book\n    if (!dir_exists(output_dir)) preview_ = FALSE\n    if (in_session) render_book(\n      files, output_format, output_dir = output_dir, preview = preview_,\n      envir = globalenv()\n    ) else {\n      args = shQuote(c(\n        bookdown_file('scripts', 'servr.R'), output_format, output_dir, preview_, files\n      ))\n      if (Rscript(args) != 0) stop('Failed to compile ', paste(files, collapse = ' '))\n    }\n  }\n  rebuild('index.Rmd', preview_ = FALSE)  # build the whole book initially\n  servr::httw('.', ..., site.dir = output_dir, handler = rebuild, daemon = daemon)\n}\n\n# can only preview HTML output via servr, so look for the first HTML format\nfirst_html_format = function() {\n  fallback = 'bookdown::gitbook'\n  if (!file.exists('index.Rmd')) return(fallback)\n  formats = rmarkdown::all_output_formats('index.Rmd', 'UTF-8')\n  formats = grep('gitbook|html', formats, value = TRUE)\n  if (length(formats) == 0) fallback else formats[1]\n}\n\nsans_ext = knitr:::sans_ext\n\n# a simple JSON serializer\ntojson = function(x) {\n  if (is.null(x)) return('null')\n  if (is.logical(x)) {\n    if (length(x) != 1 || any(is.na(x)))\n      stop('Logical values of length > 1 and NA are not supported')\n    return(tolower(as.character(x)))\n  }\n  if (is.character(x) || is.numeric(x)) {\n    return(json_vector(x, length(x) != 1 || inherits(x, 'AsIs'), is.character(x)))\n  }\n  if (is.list(x)) {\n    if (length(x) == 0) return('{}')\n    return(if (is.null(names(x))) {\n      json_vector(unlist(lapply(x, tojson)), TRUE, quote = FALSE)\n    } else {\n      nms = paste0('\"', names(x), '\"')\n      paste0('{\\n', paste(nms, unlist(lapply(x, tojson)), sep = ': ', collapse = ',\\n'), '\\n}')\n    })\n  }\n  stop('The class of x is not supported: ', paste(class(x), collapse = ', '))\n}\n\nsame_path = function(f1, f2, ...) {\n  normalizePath(f1, ...) == normalizePath(f2, ...)\n}\n\nin_dir = knitr:::in_dir\n\n# base64 encode resources in url(\"\")\nbase64_css = function(css, exts = 'png', overwrite = FALSE) {\n  x = readUTF8(css)\n  r = sprintf('[.](%s)$', paste(exts, collapse = '|'))\n  m = gregexpr('url\\\\(\"[^\"]+\"\\\\)', x)\n  regmatches(x, m) = lapply(regmatches(x, m), function(ps) {\n    if (length(ps) == 0) return(ps)\n    ps = gsub('^url\\\\(\"|\"\\\\)$', '', ps)\n    sprintf('url(\"%s\")', sapply(ps, function(p) {\n      if (grepl(r, p) && file.exists(p)) knitr::image_uri(p) else p\n    }))\n  })\n  if (overwrite) writeUTF8(x, css) else x\n}\n\nfiles_cache_dirs = function(dir = '.') {\n  if (!dir_exists(dir)) return(character())\n  out = list.files(dir, '_(files|cache)$', full.names = TRUE)\n  out = out[dir_exists(out)]\n  out = out[basename(out) != '_bookdown_files']\n  out\n}\n\n# file.rename() does not work if target directory is not empty, so we just copy\n# everything from `from` to `to`, and delete `from`\nmove_dir = function(from, to) {\n  if (!dir_exists(to)) return(file.rename(from, to))\n  if (file.copy(list.files(from, full.names = TRUE), to, recursive = TRUE))\n    unlink(from, recursive = TRUE)\n}\n\nmove_dirs = function(from, to) mapply(move_dir, from, to)\n\nexisting_files = function(x, first = FALSE) {\n  x = x[file.exists(x)]\n  if (first) head(x, 1) else x\n}\n\nexisting_r = function(base, first = FALSE) {\n  x = apply(expand.grid(base, c('R', 'r')), 1, paste, collapse = '.')\n  existing_files(x, first)\n}\n\nhtml_or_latex = function(format) {\n  if (grepl('(html|gitbook|epub)', format)) return('html')\n  if (grepl('pdf', format)) return('latex')\n  switch(format, tufte_book2 = 'latex', tufte_handout2 = 'latex')\n}\n\nverify_rstudio_version = function() {\n  if (requireNamespace('rstudioapi', quietly = TRUE) && rstudioapi::isAvailable()) {\n    if (!rstudioapi::isAvailable('0.99.1200')) warning(\n      'Please install a newer version of the RStudio IDE: ',\n      'https://www.rstudio.com/products/rstudio/download/'\n    )\n  } else if (!rmarkdown::pandoc_available('1.17.2')) warning(\n    \"Please install or upgrade Pandoc to at least version 1.17.2; \",\n    \"or if you are using RStudio, you can just install RStudio 1.0+.\"\n  )\n}\n\nstr_trim = function(x) gsub('^\\\\s+|\\\\s+$', '', x)\n\n`%n%` = knitr:::`%n%`\n\n# a theorem engine for knitr (can also be used for lemmas, definitions, etc)\neng_theorem = function(options) {\n  type = options$type %n% 'theorem'\n  if (!(type %in% names(theorem_abbr))) stop(\n    \"The type of theorem '\", type, \"' is not supported yet.\"\n  )\n  options$type = type\n  label = paste(theorem_abbr[type], options$label, sep = ':')\n  html.before2 = sprintf('(\\\\#%s)', label)\n  name = options$name\n  if (length(name) == 1) {\n    options$latex.options = sprintf('[%s]', name)\n    html.before2 = paste(html.before2, sprintf('\\\\iffalse (%s) \\\\fi ', name))\n  }\n  options$html.before2 = sprintf(\n    '<span class=\"%s\" id=\"%s\"><strong>%s</strong></span>', type, label, html.before2\n  )\n  knitr:::eng_block2(options)\n}\n\n# a proof engine for unnumbered math environments\neng_proof = function(options) {\n  type = options$type %n% 'proof'\n  if (!(type %in% names(label_names_math2))) stop(\n    \"The type of proof '\", type, \"' is not supported yet.\"\n  )\n  options$type = type\n  name = options$name\n  if (length(name) == 1) {\n    options$latex.options = sprintf('[%s]', sub('[.]\\\\s*$', '', name))\n  }\n  options$html.before2 = sprintf(\n    '\\\\iffalse <span class=\"%s\"><em>%s</em></span> \\\\fi ', type,\n    if (length(name) == 1) name else label_prefix(type, label_names_math2)\n  )\n  knitr:::eng_block2(options)\n}\n\nregister_eng_math = function(envs, engine) {\n  knitr::knit_engines$set(setNames(lapply(envs, function(env) {\n    function(options) {\n      options$type = env\n      engine(options)\n    }\n  }), envs))\n}\n",
    "created" : 1493891759072.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2749468555",
    "id" : "97A40BE7",
    "lastKnownWriteTime" : 1479720606,
    "last_content_update" : 1479720606,
    "path" : "~/Documents/git/bookdown/R/utils.R",
    "project_path" : null,
    "properties" : {
    },
    "relative_order" : 7,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}