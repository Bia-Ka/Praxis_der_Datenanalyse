<!DOCTYPE html>
<html  lang="de-De">

<head>

  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title>Praxis der Datenanalyse</title>
  <meta content="text/html; charset=UTF-8" http-equiv="Content-Type">
  <meta name="description" content="Eine Einführung in moderne Statistik für Praktiker">
  <meta name="generator" content="bookdown 0.2.3 and GitBook 2.6.7">

  <meta property="og:title" content="Praxis der Datenanalyse" />
  <meta property="og:type" content="book" />
  
  <meta property="og:image" content="cover.jpg" />
  <meta property="og:description" content="Eine Einführung in moderne Statistik für Praktiker" />
  <meta name="github-repo" content="sebastiansauer/Praxis_der_Datenanalyse" />

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="Praxis der Datenanalyse" />
  
  <meta name="twitter:description" content="Eine Einführung in moderne Statistik für Praktiker" />
  <meta name="twitter:image" content="cover.jpg" />

<meta name="author" content="Sebastian Sauer, Matthias Gehrke, Karsten Lübke, Oliver Gansser">


<meta name="date" content="2017-04-23">

  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  
  
<link rel="prev" href="praxisprobleme-der-datenaufbereitung.html">
<link rel="next" href="deskriptive-statistiken-berechnen.html">

<script src="libs/jquery-2.2.3/jquery.min.js"></script>
<link href="libs/gitbook-2.6.7/css/style.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-bookdown.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-highlight.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-search.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-fontsettings.css" rel="stylesheet" />









<style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
</style>

<link rel="stylesheet" href="style.css" type="text/css" />
</head>

<body>


  <div class="book without-animation with-summary font-size-2 font-family-1" data-basepath=".">

    <div class="book-summary">
      <nav role="navigation">

true

      </nav>
    </div>

    <div class="book-body">
      <div class="body-inner">
        <div class="book-header" role="navigation">
          <h1>
            <i class="fa fa-circle-o-notch fa-spin"></i><a href="./">Praxis der Datenanalyse</a>
          </h1>
        </div>

        <div class="page-wrapper" tabindex="-1" role="main">
          <div class="page-inner">

            <section class="normal" id="section-">
<div id="datenaufbereitung" class="section level2">
<h2><span class="header-section-number">5.1</span> Datenaufbereitung</h2>
<div id="auf-fehlende-werte-prufen" class="section level3">
<h3><span class="header-section-number">5.1.1</span> Auf fehlende Werte prüfen</h3>
<p>Das geht recht einfach mit <code>summarise(mein_dataframe)</code>. Der Befehl liefert für jede Spalte des Dataframe <code>mein_dataframe</code> die Anzahl der fehlenden Werte zurück.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">wo_men &lt;-<span class="st"> </span><span class="kw">read.csv</span>(<span class="st">&quot;https://sebastiansauer.github.io/data/wo_men.csv&quot;</span>)
<span class="kw">glimpse</span>(wo_men)</code></pre></div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">wo_men &lt;-<span class="st"> </span><span class="kw">read.csv</span>(<span class="st">&quot;data/wo_men.csv&quot;</span>)
<span class="kw">glimpse</span>(wo_men)
<span class="co">#&gt; Observations: 101</span>
<span class="co">#&gt; Variables: 5</span>
<span class="co">#&gt; $ X         &lt;int&gt; 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 1...</span>
<span class="co">#&gt; $ time      &lt;fctr&gt; 04.10.2016 17:58:51, 04.10.2016 17:58:59, 04.10.201...</span>
<span class="co">#&gt; $ sex       &lt;fctr&gt; woman, woman, woman, woman, man, woman, woman, woma...</span>
<span class="co">#&gt; $ height    &lt;dbl&gt; 160, 171, 174, 176, 195, 157, 160, 178, 168, 171, 16...</span>
<span class="co">#&gt; $ shoe_size &lt;dbl&gt; 40, 39, 39, 40, 46, 37, 38, 39, 38, 41, 39, 44, 38, ...</span></code></pre></div>
</div>
<div id="falle-mit-fehlenden-werte-loschen" class="section level3">
<h3><span class="header-section-number">5.1.2</span> Fälle mit fehlenden Werte löschen</h3>
<p>Weist eine Variable (Spalte) “wenig” fehlende Werte auf, so kann es schlau sein, nichts zu tun. Eine andere Möglichkeit besteht darin, alle entsprechenden Zeilen zu löschen. Man sollte aber schauen, wie viele Zeilen dadurch verloren gehen.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">nrow</span>(wo_men)
<span class="co">#&gt; [1] 101</span>
wo_men %&gt;%<span class="st"> </span>
<span class="st">  </span>na.omit %&gt;%<span class="st"> </span>
<span class="st">  </span>nrow
<span class="co">#&gt; [1] 100</span></code></pre></div>

<div class="rmdcaution">
<p>Bei mit der Pfeife verketteten Befehlen darf man für Funktionen die runden Klammern weglassen, wenn man keinen Parameter schreibt. Also <code>nrow</code> ist erlaubt bei <code>dplyr</code>, wo es eigentlich <code>nrow()</code> heißen müsste. Sie dürfen die Klammern natürlich schreiben, aber sie müssen nicht.</p>
</div>
<p></p>
<p>Hier verlieren wir nur 1 Zeile, das verschmerzen wir. Welche eigentlich?</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">wo_men %&gt;%<span class="st"> </span>
<span class="st">  </span>rownames_to_column %&gt;%<span class="st">  </span><span class="co"># Zeilennummer werden eine eigene Spalte</span>
<span class="st">  </span>dplyr::<span class="kw">filter</span>(!<span class="kw">complete.cases</span>(.))  <span class="co"># Nur die nicht-kompletten Fälle filtern</span>
<span class="co">#&gt;   rowname  X                time sex height shoe_size</span>
<span class="co">#&gt; 1      86 86 11.10.2016 12:44:06         NA        NA</span></code></pre></div>
<p>Man beachte, dass der Punkt <code>.</code> für den Datensatz steht, wie er vom letzten Schritt weitergegeben wurde. Innerhalb einer dplyr-Befehls-Kette können wir den Datensatz, wie er im letzten Schritt beschaffen war, stets mit <code>.</code> ansprechen; ganz praktisch, weil schnell zu tippen. Natürlich könnten wir diesen Datensatz jetzt als neues Objekt speichern und damit weiter arbeiten. Das Ausrufezeichen <code>!</code> steht für logisches “Nicht”.</p>
<p>In Pseudo-Syntax liest es sich so:</p>

<div class="rmdpseudocode">
<p>Nehme den Datensatz <code>wo_men</code> UND DANN…<br />
Mache aus den Zeilennamen (hier identisch zu Zeilennummer) eine eigene Spalte UND DANN…<br />
filtere die nicht-kompletten Fälle</p>
</div>
<p></p>
</div>
<div id="fehlende-werte-ggf.-ersetzen" class="section level3">
<h3><span class="header-section-number">5.1.3</span> Fehlende Werte ggf. ersetzen</h3>
<p>Ist die Anzahl der fehlenden Werte zu groß, als dass wir es verkraften könnten, die Zeilen zu löschen, so können wir die fehlenden Werte ersetzen. Allein, das ist ein weites Feld und übersteigt den Anspruch dieses Kurses<a href="#fn29" class="footnoteRef" id="fnref29"><sup>29</sup></a>. Eine einfache, aber nicht die beste Möglichkeit, besteht darin, die fehlenden Werte durch einen repräsentativen Wert, z.B. den Mittelwert der Spalte, zu ersetzen.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">wo_men$height &lt;-<span class="st"> </span><span class="kw">replace</span>(wo_men$height, <span class="kw">is.na</span>(wo_men$height), <span class="kw">mean</span>(wo_men$height, <span class="dt">na.rm =</span> <span class="ot">TRUE</span>))
  </code></pre></div>
<p><code>replace</code> (aus dem “Standard-R”, d.h. Paket “base”) ersetzt Werte aus dem Vektor <code>wo_men$height</code> alle Werte, für die <code>is.na(wo_men$height)</code> wahr ist. Diese Werte werden durch den Mittelwert der Spalte ersetzt<a href="#fn30" class="footnoteRef" id="fnref30"><sup>30</sup></a>.</p>
</div>
<div id="nach-fehlern-suchen" class="section level3">
<h3><span class="header-section-number">5.1.4</span> Nach Fehlern suchen</h3>
<p>Leicht schleichen sich Tippfehler oder andere Fehler ein. Man sollte darauf prüfen; so könnte man sich ein Histogramm ausgeben lassen pro Variable, um “ungewöhnliche” Werte gut zu erkennen. Meist geht das besser als durch das reine Betrachten von Zahlen. Gibt es wenig unterschiedliche Werte, so kann man sich auch die unterschiedlichen Werte ausgeben lassen.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">wo_men %&gt;%<span class="st"> </span>
<span class="st">  </span>dplyr::<span class="kw">count</span>(shoe_size) %&gt;%<span class="st"> </span>
<span class="st">  </span>head  <span class="co"># nur die ersten paar Zeilen</span>
<span class="co">#&gt; # A tibble: 6 × 2</span>
<span class="co">#&gt;   shoe_size     n</span>
<span class="co">#&gt;       &lt;dbl&gt; &lt;int&gt;</span>
<span class="co">#&gt; 1      35.0     1</span>
<span class="co">#&gt; 2      36.0     6</span>
<span class="co">#&gt; 3      36.5     1</span>
<span class="co">#&gt; 4      37.0    14</span>
<span class="co">#&gt; 5      38.0    26</span>
<span class="co">#&gt; 6      39.0    18</span></code></pre></div>
</div>
<div id="ausreiser-identifizieren" class="section level3">
<h3><span class="header-section-number">5.1.5</span> Ausreiser identifizieren</h3>
<p>Ähnlich zu Fehlern, steht man Ausreisern häufig skeptisch gegenüber. Allerdings kann man nicht pauschal sagen, das Extremwerte entfernt werden sollen: Vielleicht war jemand in der Stichprobe wirklich nur 1.20m groß? Hier gilt es, begründet und nachvollziehbar im Einzelfall zu entscheiden. Histogramme und Boxplots sind wieder ein geeignetes Mittel, um Ausreiser zu finden.</p>
<p><img src="043_Typische_Probleme_Datenanalyse_files/figure-html/unnamed-chunk-9-1.png" width="70%" style="display: block; margin: auto;" /></p>
</div>
<div id="hochkorrelierte-variablen-finden" class="section level3">
<h3><span class="header-section-number">5.1.6</span> Hochkorrelierte Variablen finden</h3>
<p>Haben zwei Leute die gleiche Meinung, so ist einer von beiden überflüssig - wird behauptet. Ähnlich bei Variablen; sind zwei Variablen sehr hoch korreliert (&gt;.9, als grober (!) Richtwert), so bringt die zweite kaum Informationszuwachs zur ersten. Und kann ausgeschlossen werden. Oder man fasst ähnliche Variablen zusammen.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">wo_men %&gt;%<span class="st"> </span>
<span class="st">  </span>dplyr::<span class="kw">select</span>(height, shoe_size) %&gt;%<span class="st"> </span>
<span class="st">  </span><span class="kw">correlate</span>() -&gt;<span class="st"> </span>km   <span class="co"># Korrelationsmatrix berechnen</span>
km  
<span class="co">#&gt; # A tibble: 2 × 3</span>
<span class="co">#&gt;     rowname height shoe_size</span>
<span class="co">#&gt;       &lt;chr&gt;  &lt;dbl&gt;     &lt;dbl&gt;</span>
<span class="co">#&gt; 1    height     NA     0.553</span>
<span class="co">#&gt; 2 shoe_size  0.553        NA</span>

km %&gt;%<span class="st"> </span>
<span class="st">  </span><span class="kw">shave</span>() %&gt;%<span class="st"> </span><span class="co"># Oberes Dreieck ist redundant, wird &quot;abrasiert&quot;</span>
<span class="st">  </span><span class="kw">rplot</span>()  <span class="co"># Korrelationsplot</span></code></pre></div>
<p><img src="043_Typische_Probleme_Datenanalyse_files/figure-html/unnamed-chunk-10-1.png" width="70%" style="display: block; margin: auto;" /></p>
<p>Die Funktion <code>correlate</code> stammt aus dem Paket <code>corrr</code><a href="#fn31" class="footnoteRef" id="fnref31"><sup>31</sup></a>, welches vorher installiert und geladen sein muss. Hier ist die Korrelation nicht zu groß, so dass wir keine weiteren Schritte unternehmen.</p>
</div>
<div id="z-standardisieren" class="section level3">
<h3><span class="header-section-number">5.1.7</span> z-Standardisieren</h3>
<p>Für eine Reihe von Analysen ist es wichtig, die Skalierung der Variablen zur vereinheitlichen. Die z-Standardisierung ist ein übliches Vorgehen. Dabei wird der Mittelwert auf 0 transformiert und die SD auf 1; man spricht - im Falle von (hinreichend) normalverteilten Variablen - jetzt von der <em>Standardnormalverteilung</em>. Unterscheiden sich zwei Objekte A und B in einer standardnormalverteilten Variablen, so sagt dies nur etwas zur relativen Position von A zu B innerhalb ihrer Verteilung aus - im Gegensatz zu den Rohwerten.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">wo_men %&gt;%<span class="st"> </span>
<span class="st">  </span><span class="kw">select_if</span>(is.numeric) %&gt;%<span class="st">  </span><span class="co"># Spalte nur auswählen, wenn numerisch</span>
<span class="st">  </span><span class="kw">scale</span>() %&gt;%<span class="st">  </span><span class="co"># z-standardisieren</span>
<span class="st">  </span><span class="kw">head</span>()  <span class="co"># nur die ersten paar Zeilen abdrucken</span>
<span class="co">#&gt;          X height shoe_size</span>
<span class="co">#&gt; [1,] -1.71 -0.132    0.0405</span>
<span class="co">#&gt; [2,] -1.67  0.146   -0.1395</span>
<span class="co">#&gt; [3,] -1.64  0.221   -0.1395</span>
<span class="co">#&gt; [4,] -1.60  0.272    0.0405</span>
<span class="co">#&gt; [5,] -1.57  0.751    1.1204</span>
<span class="co">#&gt; [6,] -1.54 -0.208   -0.4994</span></code></pre></div>
<p>Dieser Befehl liefert zwei z-standardisierte Spalten zurück. Kommoder ist es aber, alle Spalten des Datensatzes zurück zu bekommen, wobei zusätzlich die z-Werte aller numerischen Variablen hinzugekommen sind:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">wo_men %&gt;%<span class="st"> </span>
<span class="st">  </span><span class="kw">mutate_if</span>(is.numeric, <span class="kw">funs</span>(<span class="st">&quot;z&quot;</span> =<span class="st"> </span>scale)) %&gt;%<span class="st"> </span>
<span class="st">  </span>head
<span class="co">#&gt;   X                time   sex height shoe_size   X_z height_z shoe_size_z</span>
<span class="co">#&gt; 1 1 04.10.2016 17:58:51 woman    160        40 -1.71   -0.132      0.0405</span>
<span class="co">#&gt; 2 2 04.10.2016 17:58:59 woman    171        39 -1.67    0.146     -0.1395</span>
<span class="co">#&gt; 3 3 04.10.2016 18:00:15 woman    174        39 -1.64    0.221     -0.1395</span>
<span class="co">#&gt; 4 4 04.10.2016 18:01:17 woman    176        40 -1.60    0.272      0.0405</span>
<span class="co">#&gt; 5 5 04.10.2016 18:01:22   man    195        46 -1.57    0.751      1.1204</span>
<span class="co">#&gt; 6 6 04.10.2016 18:01:53 woman    157        37 -1.54   -0.208     -0.4994</span></code></pre></div>
<p>Der Befehl <code>mutate</code> berechnet eine neue Spalte; <code>mutate_if</code> tut dies, wenn die Spalte numerisch ist. Die neue Spalte wird berechnet als z-Transformierung der alten Spalte; zum Spaltenname wird ein “_z&quot; hinzugefügt. Natürlich hätten wir auch mit <code>select</code> “händisch” die relevanten Spalten auswählen können.</p>
</div>
<div id="quasi-konstante-finden" class="section level3">
<h3><span class="header-section-number">5.1.8</span> Quasi-Konstante finden</h3>
<p>Hat eine Variable nur einen Wert, so verdient sie die Ehrenbezeichnung “Variable” nicht wirklich. Haben wir z.B. nur Männer im Datensatz, so kann das Geschlecht nicht für Unterschiede im Einkommen verantwortlich sein. Besser die Variable Geschlecht dann zu entfernen. Auch hier sind Histogramme oder Boxplots von Nutzen zur Identifiktion von (Quasi-)Konstanten. Alternativ kann man sich auch pro die Streuung (numerische Variablen) oder die Anzahl unterschiedlicher Werte (qualitative Variablen) ausgeben lassen.</p>
</div>
<div id="auf-normalverteilung-prufen" class="section level3">
<h3><span class="header-section-number">5.1.9</span> Auf Normalverteilung prüfen</h3>
<p>Einige statistische Verfahren gehen von normalverteilten Variablen aus, daher macht es Sinn, Normalverteilung zu prüfen. <em>Perfekte</em> Normalverteilung ist genau so häufig wie <em>perfekte</em> Kreise in der Natur. Entsprechend werden Signifikanztests, die ja auf perfekte Normalverteilung prüfen, <em>immer signifikant</em> sein, sofern die <em>Stichprobe groß</em> genug ist. Daher ist meist zweckmäßiger, einen graphischen “Test” durchzuführen: ein Histogramm oder ein Dichte-Diagramm als “glatt geschmiergelte” Variante des Histogramms bieten sich an.</p>
<p><img src="043_Typische_Probleme_Datenanalyse_files/figure-html/unnamed-chunk-13-1.png" width="70%" style="display: block; margin: auto;" /></p>
<p>Während die Körpergröße sehr deutlich normalverteilt ist, ist die Schuhgröße recht schief. Bei schiefen Verteilung können Transformationen Abhilfe schaffen. Hier erscheint die Schiefe noch erträglich, so dass wir keine weiteren Maßnahmen einleiten.</p>
</div>
<div id="werte-umkodieren-und-binnen" class="section level3">
<h3><span class="header-section-number">5.1.10</span> Werte umkodieren und “binnen”</h3>
<p><em>Umkodieren</em> meint, die Werte zu ändern. Man sieht immer mal wieder, dass die Variable “gender” (Geschlecht) mit <code>1</code> und <code>2</code> kodiert ist. Verwechslungen sind da vorpragmmiert (“Ich bin mir echt ziemlich sicher, dass ich 1 für Männer kodiert habe, wahrscheinlich…”). Besser wäre es, die Ausprägungen <code>male</code> und <code>female</code> (“Mann”, “Frau”) o.ä. zu verwenden (vgl. Abb. <a href="datenaufbereitung.html#fig:umkodieren">5.1</a>).</p>
<div class="figure" style="text-align: center"><span id="fig:umkodieren"></span>
<img src="images/umkodieren_crop.pdf" alt="Sinnbild für Umkodieren" width="70%" />
<p class="caption">
Abbildung 5.1: Sinnbild für Umkodieren
</p>
</div>
<p><em>Binnen</em> meint, eine kontinuierliche Variablen in einige Bereiche (mindestens 2) zu zerschneiden. Ein Bild erläutert das am einfachsten (vgl. Abb. <a href="datenaufbereitung.html#fig:cut-schere">5.2</a>).</p>
<div class="figure" style="text-align: center"><span id="fig:cut-schere"></span>
<img src="images/cut_schere_crop.pdf" alt="Sinnbild zum 'Binnen'" width="70%" />
<p class="caption">
Abbildung 5.2: Sinnbild zum ‘Binnen’
</p>
</div>
<div id="umkodieren-und-binnen-mit-carrecode" class="section level4">
<h4><span class="header-section-number">5.1.10.1</span> Umkodieren und binnen mit <code>car::recode</code></h4>
<p>Manchmal möchte man z.B. negativ gepolte Items umdrehen oder bei kategoriellen Variablen kryptische Bezeichnungen in sprechendere umwandeln. Hier gibt es eine Reihe praktischer Befehle, z.B. <code>recode</code> aus dem Paket <code>car</code>. Schauen wir uns ein paar Beispiele zum Umkodieren an.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">
stats_test &lt;-<span class="st"> </span><span class="kw">read.csv</span>(<span class="st">&quot;data/test_inf_short.csv&quot;</span>)

stats_test$score_fac &lt;-<span class="st"> </span>car::<span class="kw">recode</span>(stats_test$study_time, <span class="st">&quot;5 = &#39;sehr viel&#39;; 2:4 = &#39;mittel&#39;; 1 = &#39;wenig&#39;&quot;</span>, <span class="dt">as.factor.result =</span> <span class="ot">TRUE</span>)
stats_test$score_fac &lt;-<span class="st"> </span>car::<span class="kw">recode</span>(stats_test$study_time, <span class="st">&quot;5 = &#39;sehr viel&#39;; 2:4 = &#39;mittel&#39;; 1 = &#39;wenig&#39;&quot;</span>, <span class="dt">as.factor.result =</span> <span class="ot">FALSE</span>)

stats_test$study_time_2 &lt;-<span class="st"> </span>car::<span class="kw">recode</span>(stats_test$study_time, <span class="st">&quot;5 = &#39;sehr viel&#39;; 4 = &#39;wenig&#39;; else = &#39;Hilfe&#39;&quot;</span>, <span class="dt">as.factor.result =</span> <span class="ot">TRUE</span>)

<span class="kw">head</span>(stats_test$study_time_2)
<span class="co">#&gt; [1] sehr viel Hilfe     sehr viel Hilfe     wenig     Hilfe    </span>
<span class="co">#&gt; Levels: Hilfe sehr viel wenig</span></code></pre></div>
<p>Der Befehle <code>recode</code> ist praktisch; mit <code>:</code> kann man “von bis” ansprechen (das ginge mit <code>c()</code> übrigens auch); <code>else</code> für “ansonsten” ist möglich und mit <code>as.factor.result</code> kann man entweder einen Faktor oder eine Text-Variable zurückgeliefert bekommen. Der ganze “Wechselterm” steht in Anführungsstrichen (<code>&quot;</code>). Einzelne Teile des Wechselterms sind mit einem Strichpunkt (<code>;</code>) voneinander getrennt.</p>
<p>Das klassiche Umkodieren von Items aus Fragebögen kann man so anstellen; sagen wir <code>interest</code> soll umkodiert werden:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">stats_test$no_interest &lt;-<span class="st"> </span>car::<span class="kw">recode</span>(stats_test$interest, <span class="st">&quot;1 = 6; 2 = 5; 3 = 4; 4 = 3; 5 = 2; 6 = 1; else = NA&quot;</span>)
<span class="kw">glimpse</span>(stats_test$no_interest)
<span class="co">#&gt;  num [1:306] 2 4 1 5 1 NA NA 4 2 2 ...</span></code></pre></div>
<p>Bei dem Wechselterm muss man aufpassen, nichts zu verwechseln; die Zahlen sehen alle ähnlich aus…</p>
<p>Testen kann man den Erfolg des Umpolens mit</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">dplyr::<span class="kw">count</span>(stats_test, interest)
<span class="co">#&gt; # A tibble: 7 × 2</span>
<span class="co">#&gt;   interest     n</span>
<span class="co">#&gt;      &lt;int&gt; &lt;int&gt;</span>
<span class="co">#&gt; 1        1    30</span>
<span class="co">#&gt; 2        2    47</span>
<span class="co">#&gt; 3        3    66</span>
<span class="co">#&gt; 4        4    41</span>
<span class="co">#&gt; 5        5    45</span>
<span class="co">#&gt; 6        6     9</span>
<span class="co">#&gt; 7       NA    68</span>
dplyr::<span class="kw">count</span>(stats_test, no_interest)
<span class="co">#&gt; # A tibble: 7 × 2</span>
<span class="co">#&gt;   no_interest     n</span>
<span class="co">#&gt;         &lt;dbl&gt; &lt;int&gt;</span>
<span class="co">#&gt; 1           1     9</span>
<span class="co">#&gt; 2           2    45</span>
<span class="co">#&gt; 3           3    41</span>
<span class="co">#&gt; 4           4    66</span>
<span class="co">#&gt; 5           5    47</span>
<span class="co">#&gt; 6           6    30</span>
<span class="co">#&gt; 7          NA    68</span></code></pre></div>
<p>Scheint zu passen. Noch praktischer ist, dass man so auch numerische Variablen in Bereiche aufteilen kann (“binnen”):</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">stats_test$Ergebnis &lt;-<span class="st"> </span>car::<span class="kw">recode</span>(stats_test$score, <span class="st">&quot;1:38 = &#39;durchgefallen&#39;; else = &#39;bestanden&#39;&quot;</span>)</code></pre></div>
<p>Natürlich gibt es auch eine Pfeifen komptatible Version, um Variablen umzukodieren bzw. zu binnen: <code>dplyr::recode</code><a href="#fn32" class="footnoteRef" id="fnref32"><sup>32</sup></a>. Die Syntax ist allerdings etwas weniger komfortabel (da strenger), so dass wir an dieser Stelle bei <code>car::recode</code> bleiben.</p>
</div>
<div id="einfaches-umkodieren-mit-einer-logik-prufung" class="section level4">
<h4><span class="header-section-number">5.1.10.2</span> Einfaches Umkodieren mit einer Logik-Prüfung</h4>
<p>Nehmen wir an, wir möchten die Anzahl der Punkte in einer Statistikklausur (<code>score</code>) umkodieren in eine Variable “bestanden” mit den zwei Ausprägungen “ja” und “nein”; der griesgrämige Professor beschließt, dass die Klausur ab 25 Punkten (von 40) bestanden sei. Die Umkodierung ist also von der Art “viele Ausprägungen in zwei Ausprägungen umkodieren”. Das kann man z.B. so erledigen:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">stats_test$bestanden &lt;-<span class="st"> </span>stats_test$score &gt;<span class="st"> </span><span class="dv">24</span>

<span class="kw">head</span>(stats_test$bestanden)
<span class="co">#&gt; [1]  TRUE  TRUE  TRUE FALSE  TRUE  TRUE</span></code></pre></div>
<p>Genauso könnte man sich die “Grenzfälle” - die Bemitleidenswerten mit 24 Punkten - anschauen (knapp daneben ist auch vorbei, so der griesgrämige Professor weiter):</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">stats_test$Grenzfall &lt;-<span class="st"> </span>stats_test$score ==<span class="st"> </span><span class="dv">24</span>

<span class="kw">count</span>(stats_test, Grenzfall)
<span class="co">#&gt; # A tibble: 2 × 2</span>
<span class="co">#&gt;   Grenzfall     n</span>
<span class="co">#&gt;       &lt;lgl&gt; &lt;int&gt;</span>
<span class="co">#&gt; 1     FALSE   294</span>
<span class="co">#&gt; 2      TRUE    12</span></code></pre></div>
<p>Natürlich könnte man auch hier “Durchpfeifen”:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">stats_test &lt;-<span class="st"> </span>
stats_test %&gt;%<span class="st"> </span>
<span class="st">  </span><span class="kw">mutate</span>(<span class="dt">Grenzfall =</span> score ==<span class="st"> </span><span class="dv">24</span>)

<span class="kw">count</span>(stats_test, Grenzfall)
<span class="co">#&gt; # A tibble: 2 × 2</span>
<span class="co">#&gt;   Grenzfall     n</span>
<span class="co">#&gt;       &lt;lgl&gt; &lt;int&gt;</span>
<span class="co">#&gt; 1     FALSE   294</span>
<span class="co">#&gt; 2      TRUE    12</span></code></pre></div>
</div>
<div id="binnen-mit-cut" class="section level4">
<h4><span class="header-section-number">5.1.10.3</span> Binnen mit <code>cut</code></h4>
<p>Numerische Werte in Klassen zu gruppieren (“to bin”, denglisch: “binnen”) kann mit dem Befehl <code>cut</code> (and friends) besorgt werden.</p>
<p>Es lassen sich drei typische Anwendungsformen unterscheiden:</p>
<p>Eine numerische Variable …</p>
<ol style="list-style-type: decimal">
<li>in <em>k</em> gleich große Klassen grupieren (gleichgroße Intervalle)</li>
<li>so in Klassen gruppieren, dass in jeder Klasse <em>n</em> Beobachtungen sind (gleiche Gruppengrößen)</li>
<li>in beliebige Klassen gruppieren</li>
</ol>
<div id="gleichgroe-intervalle" class="section level5">
<h5><span class="header-section-number">5.1.10.3.1</span> Gleichgroße Intervalle</h5>
<p>Nehmen wir an, wir möchten die numerische Variable “Körpergröße” in drei Gruppen einteilen: “klein”, “mittel” und “groß”. Der Range von Körpergröße soll gleichmäßig auf die drei Gruppen aufgeteilt werden, d.h. der Range (Interval) der drei Gruppen soll gleich groß sein. Dazu kann man <code>cut_interval</code> aus <code>ggplot2</code> nehmen [^d.h. <code>ggplot2</code> muss geladen sein; wenn man <code>tidyverse</code> lädt, wird <code>ggplot2</code> automatisch auch geladen].</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">wo_men &lt;-<span class="st"> </span><span class="kw">read_csv</span>(<span class="st">&quot;data/wo_men.csv&quot;</span>)

wo_men %&gt;%<span class="st"> </span>
<span class="st">  </span><span class="kw">filter</span>(height &gt;<span class="st"> </span><span class="dv">150</span>, height &lt;<span class="st"> </span><span class="dv">220</span>) -&gt;<span class="st"> </span>wo_men2

temp &lt;-<span class="st"> </span><span class="kw">cut_interval</span>(<span class="dt">x =</span> wo_men2$height, <span class="dt">n =</span> <span class="dv">3</span>)

<span class="kw">levels</span>(temp)
<span class="co">#&gt; [1] &quot;[155,172]&quot; &quot;(172,189]&quot; &quot;(189,206]&quot;</span></code></pre></div>
<p><code>cut_interval</code> liefert eine Variabel vom Typ <code>factor</code> zurück.</p>
</div>
<div id="gleiche-gruppengroen" class="section level5">
<h5><span class="header-section-number">5.1.10.3.2</span> Gleiche Gruppengrößen</h5>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">temp &lt;-<span class="st"> </span><span class="kw">cut_number</span>(wo_men2$height, <span class="dt">n =</span> <span class="dv">2</span>)
<span class="kw">str</span>(temp)
<span class="co">#&gt;  Factor w/ 2 levels &quot;[155,169]&quot;,&quot;(169,206]&quot;: 1 2 2 2 2 1 1 2 1 2 ...</span></code></pre></div>
<p>Mit <code>cut_number</code> (aus ggplot2) kann man einen Vektor in <code>n</code> Gruppen mit (etwa) gleich viel Observationen einteilen.</p>
<blockquote>
<p>Teilt man einen Vektor in zwei gleich große Gruppen, so entspricht das einer Aufteilung am Median (Median-Split).</p>
</blockquote>
</div>
<div id="in-beliebige-klassen-gruppieren" class="section level5">
<h5><span class="header-section-number">5.1.10.3.3</span> In beliebige Klassen gruppieren</h5>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">wo_men$groesse_gruppe &lt;-<span class="st"> </span><span class="kw">cut</span>(wo_men$height, 
                             <span class="dt">breaks =</span> <span class="kw">c</span>(-<span class="ot">Inf</span>, <span class="dv">100</span>, <span class="dv">150</span>, <span class="dv">170</span>, <span class="dv">200</span>, <span class="dv">230</span>, <span class="ot">Inf</span>))

<span class="kw">count</span>(wo_men, groesse_gruppe)
<span class="co">#&gt; # A tibble: 6 × 2</span>
<span class="co">#&gt;   groesse_gruppe     n</span>
<span class="co">#&gt;           &lt;fctr&gt; &lt;int&gt;</span>
<span class="co">#&gt; 1     (-Inf,100]     4</span>
<span class="co">#&gt; 2      (150,170]    55</span>
<span class="co">#&gt; 3      (170,200]    38</span>
<span class="co">#&gt; 4      (200,230]     2</span>
<span class="co">#&gt; 5     (230, Inf]     1</span>
<span class="co">#&gt; 6             NA     1</span></code></pre></div>
<p><code>cut</code> ist im Standard-R (Paket “base”) enthalten. Mit <code>breaks</code> gibt man die Intervallgrenzen an. Zu beachten ist, dass man eine Unter- bzw. Obergrenze angeben muss. D.h. der kleinste Wert in der Stichprobe wird nicht automatisch als unterste Intervallgrenze herangezogen. Anschaulich gesprochen ist <code>cut</code> ein Messer, das ein Seil (die kontinuierliche Variable) mit einem oder mehreren Schnitten zerschneidet (vgl. Abb. <a href="datenaufbereitung.html#fig:cut-schere">5.2</a>).</p>
</div>
</div>
</div>
</div>
<div class="footnotes">
<hr />
<ol start="29">
<li id="fn29"><p>Das sagen Autoren, wenn sie nicht genau wissen, wie etwas funktioniert.<a href="datenaufbereitung.html#fnref29">↩</a></p></li>
<li id="fn30"><p>Hier findet sich eine ausführlichere Darstellung: <a href="https://sebastiansauer.github.io/checklist_data_cleansing/index.html" class="uri">https://sebastiansauer.github.io/checklist_data_cleansing/index.html</a><a href="datenaufbereitung.html#fnref30">↩</a></p></li>
<li id="fn31"><p><a href="https://github.com/drsimonj/corrr" class="uri">https://github.com/drsimonj/corrr</a><a href="datenaufbereitung.html#fnref31">↩</a></p></li>
<li id="fn32"><p><a href="https://blog.rstudio.org/2016/06/27/dplyr-0-5-0/" class="uri">https://blog.rstudio.org/2016/06/27/dplyr-0-5-0/</a><a href="datenaufbereitung.html#fnref32">↩</a></p></li>
</ol>
</div>
            </section>

          </div>
        </div>
      </div>
<a href="praxisprobleme-der-datenaufbereitung.html" class="navigation navigation-prev " aria-label="Previous page"><i class="fa fa-angle-left"></i></a>
<a href="deskriptive-statistiken-berechnen.html" class="navigation navigation-next " aria-label="Next page""><i class="fa fa-angle-right"></i></a>

<script src="libs/gitbook-2.6.7/js/app.min.js"></script>
<script src="libs/gitbook-2.6.7/js/lunr.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-search.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-sharing.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-fontsettings.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-bookdown.js"></script>
<script src="libs/gitbook-2.6.7/js/jquery.highlight.js"></script>
<script>
require(["gitbook"], function(gitbook) {
gitbook.start({
"sharing": {
"github": false,
"facebook": true,
"twitter": true,
"google": false,
"weibo": false,
"instapper": false,
"vk": false,
"all": ["facebook", "google", "twitter", "weibo", "instapaper"]
},
"fontsettings": {
"theme": "white",
"family": "sans",
"size": 2
},
"edit": {
"link": null,
"text": null
},
"download": null,
"toc": {
"collapse": "section",
"scroll_highlight": true
},
"search": true
});
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    if (location.protocol !== "file:" && /^https?:/.test(script.src))
      script.src  = script.src.replace(/^https?:/, '');
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>
</body>

</html>
